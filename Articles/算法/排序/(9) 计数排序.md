#### 定义

计数排序是一种稳定的线性时间整数排序算法。计数排序使用一个额外的辅助数组/计数数组C，其中第i 个元素是待排序数组A 中值等于i 的元素的个数。然后根据数组C 来将A 中的元素排到正确的位置。

#### 实现思路

1）找出待排序的数组中最大的元素构造辅助数组
2）统计数组中每个值为i的元素出现的次数，存入数组C的第i项
3）将数组C中的数取出，得到的就是已排好序的数组

#### 代码实现

```javascript
function countSort (arr) {
  // 求出数组中最大的数
  let max = Math.max(...arr)
  // 创建一个大小为max + 1的辅助数组，初始值为0
  let buckets = new Array(max + 1).fill(0)
  // 将待排序数组存放到辅助数组中
  arr.forEach(item => {
    buckets[item] ++
  })
  let resultArr = []
  let index = 0

  for (let i = 0; i < buckets.length; i ++) {
    let m = buckets[i]
    while (m) {
      resultArr[index ++] = i
      m--
    }
  }

  return resultArr
}
```

但是上述的简易版实现有一定得局限性，参考如下的数组：

```javascript
[40, 39, 47, 56]
```
如果以数列的最大值去创建辅助数组，会发现[0，39]的空间都是被浪费的，要解决这个问题，可以转变思路，不再以（输入数列的最大值+1）作为统计数组的长度，而是以（数列最大值和最小值的差+1）作为统计数组的长度

还是用上述数组作为例子

```javascript
给出 [40, 39, 42, 47]

辅助数组为 new Array(47 - 39 + 1).fill(0)

[0, 0, 0, 0, 0, 0, 0, 0, 0]

对于第一个整数40，对应的统计数组下标是 40-39 = 1

以待排序数组最小值39为偏移量构造出的辅助数组为

[1, 1, 0, 1, 0, 0, 0, 0, 1]

```

另一个问题是，上述简版的计数排序只是简单地按照统计数组的下标输出了元素值，并没有真正的对原始数据进行了排序

比如给定如下一组数据

```javascript
[15, 11, 11, 10, 23]
```
这里有两个index为11的数据，重复的元素在上述算法里面是不具备稳定性的，所谓的稳定性就是：具有相同值的元素在输出数组中的相对次序与它们在输入数组中的相对次序是相同的

为了修补上述两种缺陷，我们可以加上两条实现思路：

1）查找待排序数组中最大和最小的元素

2）统计每个值为i的元素的出现次数并构造辅助数组C[i]

3）对所有计数开始累加(从min开始,每一项和前一项相加)

4）反向填充目标数组,将每个元素i放在新数组的第C[i]项,每放一个元素,计数-1.

#### 代码实现

```javascript
function countSort (arr) {
  // 求出数组中最大和最小的数
  let max = Math.max(...arr)
  let min = Math.min(...arr)
  // 创建一个大小为max - min + 1的辅助数组，初始值为0
  let buckets = new Array(max - min + 1).fill(0)
  // 将待排序数组存放到辅助数组中
  arr.forEach(item => {
    buckets[item - min] ++
  })
  // 为了保持排序的稳定性，对辅助数组做一次累加操作，将每一项和前一项进行相加
  // 这样相加的目的，是让统计数组存储的元素值，等于相应整数的最终排序位置
  for (let i = 1; i < buckets.length; i ++) {
    buckets[i] = buckets[i] + buckets[i - 1]
  }
  // 构造输出数组，长度和输入数列一致
  let resultArr = new Array(arr.length)
  // 逆向遍历输入数组
  // 逆序的目的是为了，当存在相同元素的时候，永远把重复的元素放在右侧，保证稳定性
  for (let i = arr.length - 1; i >= 0; i --) {
    let offsetPos = arr[i] - min
    // 通过偏移量计算得到待排序数组当前元素在辅助数组的位置，或者该位置上辅助数组的值，这个值就是待排序数组在输出数组里面的最终的排序位置
    let resultIndex = buckets[offsetPos]
    resultArr[resultIndex - 1] = arr[i]
    // 如果有重复的元素，位置会从右向左放置，所以代表着最终排序位置的值需要减一
    buckets[offsetPos] --
  }
  return resultArr
}
```

#### 时间复杂度

```markdownk
O(n+k)
```

#### 特点

计数排序是一个稳定的排序算法。当输入的元素是 n 个 0到 k 之间的整数时，时间复杂度是O(n+k)，空间复杂度也是O(n+k)，其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。
