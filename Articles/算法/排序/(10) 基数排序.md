#### 定义

在计算机科学中，基数排序是一种非比较的整数排序算法，它通过用分享相同重要的位置和值方法分类得来的整数键来对数据进行排序。该排序需要位置表示法，但是由于整数可以表示字符串(例如名称或日期) 和特殊格式化的浮点数，基数排序的对象可以不限于整数。基数排序可以追溯到1887年赫尔曼·霍勒里斯在制表机上的工作。

大多数数字计算机内部都将其所有数据表示为二进制数字的电子表示形式，因此用一组二进制数字表示形式处理整数表示的数字是最方便的。为了可以实现基数排序，我们使该排序从最高有效位(MSD) 或最低有效位(LSD) 开始。例如，将目标数字组1234 排序为列表时，可以从1 或4 开始。

LSD 基数排序通常使用以下排序顺序：短键排在长键之前，相同长度的键按词法lexicographically 排序。这与整数表示的正常顺序是一致的，例如序列1、2、3、4、5、6、7、8、9、10、11。

MSD 基数排序则使用词典顺序，它适用于对字符串(如单词) 或固定长度的整数进行排序。一个序列，如“b, c, d, e, f, g, h, i, j, ba”将会按词法排序为“b, ba, c, d, e, f, g, h, i, j”。如果词典排序用于表示可变量长度的整数，例如从1到10 的数字，输出将表示为1, 10, 2, 3, 4, 5, 6, 7, 8, 9。

#### 实现思路

将待排序数组中所有需要比较的元素（正整数）统一表示为同样的数位长度，数位较短的数在前面的位数补上零

为了可以实现基数排序，我们使该排序从最高有效位(MSD) 或最低有效位(LSD) 开始，这里以LSD为例，从最低位开始，依次进行排序

这样，从最低位排序一直到最高位排序完成以后，数列就变成了一个有序序列。

#### 代码实现

```javascript
// LSD实现形式
function radixSort (arr) {
  // 对于序列中的每个整数的每一位都可以看成是一个桶，而该位上的数字就可以认为是这个桶的键值

  // 取最大值 最大值的位数就是要循环遍历的次数
  let max = Math.max(...arr)
  // 定义一个桶
  let buckets = Array.from({ length: 10 }, () => [])
  // 定义当前排序的位数 个/百/千...
  let digit = 1
  while (digit <= max) {
    // 将待排序的数组，按照个/百/千的顺序依次放入桶
    arr.forEach(item => {
      // 求当前需要入桶的位数的值
      const digitNum = Math.floor((item % (digit * 10)) / digit)
      // 把该位数的值放到桶buckets中
      buckets[digitNum].push(item)
    })
    // 从桶buckets中取值
    // 完成此步后 就完成了一次位数排序
    let index = 0
    buckets.forEach(bucket => {
      while (bucket.length > 0) {
        // shift从头部取值
        // 保证按照队列先入先出
        arr[index++] = bucket.shift()
      }
    })
    // 进行下一位的排序
    digit*= 10
  }

  return arr
}
```
下面说一下MSD形式的基数排序：它与LSD的形式相反，她会遍历所有元素，取最大值，得到最大位数，建立10个桶。这时从最高位取起。不足的对应位置为0

然后检测每个桶中的数据，当桶中的元素个数大于一个,就对这个桶进行递归并且进行下一位的分组

举个🌰

以一组数据为例：

```markdown
36   9   0   25   1   49   64   16   81  4 120
```
遍历所有元素，取最大值，得到最大位数为百位，建立10个桶，将数据依次入桶

```markdown
0号桶：36 9 0 25 1 49 64 16 81 4

1号桶：120

2-9号桶：无
```
接下来对每个长度大于1的桶进行内部排序，排序方式也是基数排序，这里另建立10个桶，对原0号桶的数据进行入桶，并且位数下降为10位

```markdown
0号桶：9 0 1 4

1号桶：16

2号桶：25

3号桶：36

4号桶：49

5号桶：无

6号桶：64

7号桶：无

8号桶：81

9号桶：无
```
继续针对0号桶降维

```markdown
0号桶：0

1号桶：1

2号桶：无

3号桶：无

4号桶：4

5号桶：无

6号桶：无

7号桶：无

8号桶：无

9号桶：9
```
这时候所有的桶都长度都不超过1，可以进行桶的收集操作，最后依次进行取出就是排好序的数组

代码实现如下：

```javascript
// MSD实现形式
function radixSort (arr) {
  // 取最大值
  let max = Math.max(...arr)
  // 获取当前入桶的位数 个/百/千 以最大数为准
  let radix = String(max).length - 1
  msdRadix(arr, arr.length, radix)
  function msdRadix (arr, len, radix) {
    // 定义一个桶
    let buckets = Array.from({ length: 10 }, () => [])
    // 将数据入桶
    for (let i = 0; i < len; i ++) {
      // 求当前需要入桶的位数的值
      const digitNum = Math.floor((arr[i] / Math.pow(10, radix)) % 10)
      buckets[digitNum].push(arr[i])
    }
    // 对子桶进行递归，查看是否有某个桶内元素数据大于1的情况
    buckets.forEach(bucket => {
      if (bucket.length > 1 && radix --) {
        msdRadix(bucket, bucket.length, radix --)
      }
    })
    // 重新拼装数据
    let index = 0
    buckets.forEach(bucket => {
      while (bucket.length) {
        arr[index++] = bucket.shift()
      }
    })
  }
  return arr
}
```

#### 时间复杂度

```markdownk
O(n)
```

#### 特点

基数排序比较适合对取值很大的数进行排序，也可用来对字符串进行排序。

但基数排序的缺点是不呈现时空局部性，因为在按位对每个数进行排序的过程中，一个数的位置可能发生巨大的变化，所以不能充分利用现代机器缓存提供的优势
