#### 定义

对于大规模乱序数组插入排序很慢，因为它只会交换相邻的元素，因此元素只能一点一点地从数组 的一端移动到另一端。例如，如果主键最小的元素正好在数组的尽头，要将它挪到正确的位置就需 要 N -1 次移动。希尔排序为了加快速度简单地改进了插入排序，交换不相邻的元素以对数组的局部 进行排序，并最终用插入排序将局部有序的数组排序，
希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。

#### 算法实现的思路

希尔排序的思想是使数组中任意间隔为 h 的元素都是有序的。这样的数组被称为 h 有序数组。换 句话说，一个 h 有序数组就是 h 个互相独立的有序数组编织在一起组成的一个数组，先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的，因此希尔排序在时间效率上比前两种方法有较大提高。

#### 算法实现

```javascript
function shellSort (arr) {
  let len = arr.length
  // 控制增量 1 2 4 8 ...
  for (let gap = Math.floor(len / 2); gap > 0; gap = Math.floor(gap / 2)) {
    // 将数组变为h有序
    for (let i = gap; i < len; i ++) {
      // 对相距距离为gap的两个元素进行大小比较
      for (let j = i; j >= gap && arr[j] < arr[j - gap]; j = j - gap) {
        // a = a + b
        arr[j - gap] = arr[j] + arr[j - gap]
        // b = a - b
        arr[j] = arr[j - gap] - arr[j]
        // a = a - b
        arr[j - gap] = arr[j - gap] - arr[j]
      }
    }
  }
  return arr
}
```

#### 时间复杂度

```markdown
O(n^1.5)
```

#### 特点

希尔排序是按照不同步长对元素进行插入排序，当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快；当元素基本有序了，步长很小，插入排序对于有序的序列效率很高。所以，希尔排序的时间复杂度会比o(n^2)好一些。
